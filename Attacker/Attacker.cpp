/*
 * Copyright 2022 The University of Adelaide
 *
 * This file is part of CacheFX.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <Attacker/Attacker.h>
#include <Random.h>

#include <vector>

using namespace std;

static double ci95factor(int32_t n)
{
  static const double tTable[] = {
      12.71, 4.303, 3.182, 2.776, 2.571, 2.447, 2.365, 2.306, 2.262, 2.228,
      2.201, 2.179, 2.160, 2.145, 2.131, 2.120, 2.110, 2.101, 2.093, 2.086,
      2.080, 2.074, 2.069, 2.064, 2.060, 2.056, 2.052, 2.048, 2.045, 2.042};
  static const int32_t ntTable = sizeof(tTable) / sizeof(tTable[0]);
  if (n < 2)
    return 1e+10;
  if (n - 2 < ntTable)
    return tTable[n - 2];
  return 1.96;
}

bool Attacker::setStats(int32_t n, double asum, double assum, double bsum,
                        double bssum)
{
  aavg = asum / n;
  asavg = assum / n;
  asd = sqrt(asavg - aavg * aavg);
  acint = ci95factor(n) * asd / sqrt((double)n);

  bavg = bsum / n;
  bsavg = bssum / n;
  bsd = sqrt(bsavg - bavg * bavg);
  bcint = ci95factor(n) * bsd / sqrt((double)n);

  if (n < 2)
    return false;
  return (aavg - acint > bavg + bcint) || (aavg + acint < bavg - bcint);
}

bool Attacker::setStats(int32_t n, double asum, double assum, double bsum,
                        double bssum, double aRealSum, double aRealSSum,
                        double bRealSum, double bRealSSum,
                        double aSelfEvictionSum, double aSelfEvictionSSum,
                        double bSelfEvictionSum, double bSelfEvictionSSum)
{
  arealavg = aRealSum / n;
  arealsavg = aRealSSum / n;
  arealsd = sqrt(arealsavg - arealavg * arealavg);

  brealavg = bRealSum / n;
  brealsavg = bRealSSum / n;
  brealsd = sqrt(brealsavg - brealavg * brealavg);

  aselfevictionavg = aSelfEvictionSum / n;
  aselfevictionsavg = aSelfEvictionSSum / n;
  aselfevictionsd =
      sqrt(aselfevictionsavg - aselfevictionavg * aselfevictionavg);

  bselfevictionavg = bSelfEvictionSum / n;
  bselfevictionsavg = bSelfEvictionSSum / n;
  bselfevictionsd =
      sqrt(bselfevictionsavg - bselfevictionavg * bselfevictionavg);

  return setStats(n, asum, assum, bsum, bssum);
}

void Attacker::round()
{
  if (curRound == secretRound)
  {
    probes = probe();
  }
  curRound++;
  if (curRound == secretRound)
  {
    prime();
    prime();
    prime();
  }
}

void Attacker::attackSetup()
{
  probes = 0;
  curRound = 0;
  if (secretRound == -1)
  {
    prime();
    prime();
    prime();
  }
  round();
}

void Attacker::train(Victim* victim, const KeyPair keys,
                     vector<uint8_t>* overrideKeyA,
                     vector<uint8_t>* overrideKeyB,
                     vector<uint8_t>* overridePlaintext)
{
  double aSum = 0.0;
  double aSSum = 0.0;

  double bSum = 0.0;
  double bSSum = 0.0;

  arealsum = 0.0;
  arealssum = 0.0;

  brealsum = 0.0;
  brealssum = 0.0;

  aselfevictionsum = 0.0;
  aselfevictionssum = 0.0;

  bselfevictionsum = 0.0;
  bselfevictionssum = 0.0;

  correctEvictions = 0;
  incorrectEvictions = 0;

  success = false;

  uint8_t output[victim->getOutputSize()];
  int32_t count = 0;

  for (i = -warmupPeriod; i < giveup; i++)
  {
    int32_t a, b;
    int32_t aLastProbe, bLastProbe;

    unique_ptr<KeyPair> keypairs;
    const vector<uint8_t>* input;
    
    // Override key for the purpose of testing, use fixed key
    // instead of getting one generated by the generator.
    if (overrideKeyA)
    {
      input = overridePlaintext;
      keypairs = make_unique<KeyPair>(*overrideKeyA, *overrideKeyB);
    }
    else
    {
      input = &victim->getRandomInput();
      keypairs = make_unique<KeyPair>(keys.first, keys.second);
    }

    const bool afirst = randomBool();

    if (afirst)
      victim->setKey(keypairs->first.data());
    else
      victim->setKey(keypairs->second.data());
    attackSetup();
    victimCall(victim, input->data(), output, afirst);

    if (secretRound == -1)
      probes = probe();
    if (afirst)
    {
      a = probes;
      aLastProbe = lastProbe;
    }
    else
    {
      b = probes;
      bLastProbe = lastProbe;
    }

    if (!afirst)
      victim->setKey(keypairs->first.data());
    else
      victim->setKey(keypairs->second.data());

    attackSetup();
    victimCall(victim, input->data(), output, !afirst);

    if (secretRound == -1)
      probes = probe();
    if (!afirst)
    {
      a = probes;
      aLastProbe = lastProbe;
    }
    else
    {
      b = probes;
      bLastProbe = lastProbe;
    }

    if (trainPostlude(i, a, aSum, aSSum, b, bSum, bSSum, count, aLastProbe,
                      bLastProbe))
      break;
  }
  return;
}

int32_t Attacker::attack(const Victim* victim, const KeyPair keys)
{
#if 0
  int32_t inputSize = victim->getInputSize();
  int32_t outputSize = victim->getOutputSize();
  uint8_t input[inputSize];
  uint8_t output[outputSize];
  double sum;
  double ssum;

  for (int32_t i = 0; i < 10000; i++) {
    sum = ssum = 0.0;
    victim->getRandomInput(input, abchoice);
    attacksetup();
    victimCall(victim, input, output);
    if (secretRound == -1)
      probes = probe();

    sum += probes;
    ssum += probes * probes;

      double avg = sum/(i+1);
      double savg = ssum/(i+1);
      double sd = sqrt(savg - avg*avg);
      double cint = 1.96 * sd / sqrt((double) (i+1));
      printf("[%6.3f, %6.3f],    A: [%6.3f, %6.3f]  B:[%6.3f, %6.3f]\n", 
	  avg - cint, avg + cint, aavg - acint, aavg + acint, bavg -bcint, bavg + bcint);
    if (i >= 4 ) {
      if ((avg - cint > bavg + bcint) || (avg + cint < bavg - bcint))
	return 1;
      if ((avg - cint > aavg + acint) || (avg + cint < aavg - acint))
	return 0;
    }
  }
#endif
  return -1;
}